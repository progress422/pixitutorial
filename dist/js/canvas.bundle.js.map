{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/collisions/src/Collisions.mjs","webpack:///./node_modules/collisions/src/modules/BVH.mjs","webpack:///./node_modules/collisions/src/modules/BVHBranch.mjs","webpack:///./node_modules/collisions/src/modules/Body.mjs","webpack:///./node_modules/collisions/src/modules/Circle.mjs","webpack:///./node_modules/collisions/src/modules/Point.mjs","webpack:///./node_modules/collisions/src/modules/Polygon.mjs","webpack:///./node_modules/collisions/src/modules/Result.mjs","webpack:///./node_modules/collisions/src/modules/SAT.mjs","webpack:///./src/canvas.js"],"names":["collision","Collisions","collResult","createResult","Application","PIXI","loader","resources","Sprite","TextureCache","utils","Rectangle","app","width","height","resolution","graphics2","Graphics","collPlayer","createPolygon","wall4","line","renderer","update","add","tilemap","player","playerMoves","speed","blockLeft","blockRight","blockBottom","blockTop","left","movingDirection","right","stop","parseTileMap","document","body","appendChild","view","setup","setBackground","draw","setPlayer","beginFill","drawPolygon","endFill","stage","addChild","graphics","ticker","delta","console","log","prevX","x","prevY","y","jump","yMomentum","gravity","vy","jumpHeight","checkCollision","vx","collPotentials","potentials","yCollided","xCollided","wall","collides","overlap","overlap_x","overlap_y","xChanged","yChanged","texture","position","set","maxSpeed","speedPerFrameOnTheGround","speedPerFrameInTheAir","speedPerFrameFalling","speedPerFrame","playerMoveInit","keyboard","up","down","press","release","isDown","changeVelocity","intensity","changeTo","velocityVector","bg","tilemapSource","fetch","then","res","json","data","rows","cols","tileWidth","tilewidth","tileHeight","tileheight","tilemapPrefix","layers","map","layer","tilesets","tileset","firstgid","tiles","loadTiles","tileImagesArr","pathToImages","tileStartId","tile","id","image","img","alias","src","load","rowNumber","index","tileX","tileY","setTileOnMap","Player","value","key","isUp","undefined","downHandler","event","preventDefault","upHandler","downListener","bind","upListener","window","addEventListener","unsubscribe","removeEventListener"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACG;AACC;AACF;AACC;AACH;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAG;AACrB;;AAEA;AACA,eAAe,aAAa;AAC5B,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA,mBAAmB,2DAAM;;AAEzB;;AAEA;AACA;;AAEA;AACA,eAAe,cAAc;AAC7B,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,gBAAgB;AAC5B,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA,mBAAmB,4DAAO;;AAE1B;;AAEA;AACA;;AAEA;AACA,eAAe,YAAY;AAC3B,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA,mBAAmB,0DAAK;;AAExB;;AAEA;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B;AACA;AACA,aAAa,2DAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA,aAAa,2DAAM;AACnB;;AAEA;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qBAAqB;AACjC,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA,SAAS,gEAAG;AACZ;AACA;;AASE;;;;;;;;;;;;;AClKF;AAAA;AAAA;AAAwC;;AAExC;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,sDAAS;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,sDAAS;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,WAAW;AAC3B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qBAAqB;AACjC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;;AAEA,gBAAgB,WAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzZA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,UAAU;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AAAA;AAAA;AAAA;AAAkC;AACH;;AAE/B;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA,SAAS,wDAAG;AACZ;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B;AACA;AACA,aAAa,mDAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA,aAAa,mDAAM;AACnB;AACA;;;;;;;;;;;;;ACrHA;AAAA;AAAA;AAA8B;;AAE9B;AACA;AACA;AACA;AACe,qBAAqB,iDAAI;AACxC;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAoC;;AAEpC;AACA;AACA;AACA;AACe,oBAAoB,oDAAO;AAC1C;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAA8B;;AAE9B;AACA;AACA;AACA;AACe,sBAAsB,iDAAI;AACzC;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,gBAAgB;AAC5B,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,gCAAgC,WAAW;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,YAAY;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACpPA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AAAA;AAAA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;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","file":"./js/canvas.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/canvas.js\");\n","import BVH     from './modules/BVH.mjs';\nimport Circle  from './modules/Circle.mjs';\nimport Polygon from './modules/Polygon.mjs';\nimport Point   from './modules/Point.mjs';\nimport Result  from './modules/Result.mjs';\nimport SAT     from './modules/SAT.mjs';\n\n/**\n * A collision system used to track bodies in order to improve collision detection performance\n * @class\n */\nclass Collisions {\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\t/** @private */\n\t\tthis._bvh = new BVH();\n\t}\n\n\t/**\n\t * Creates a {@link Circle} and inserts it into the collision system\n\t * @param {Number} [x = 0] The starting X coordinate\n\t * @param {Number} [y = 0] The starting Y coordinate\n\t * @param {Number} [radius = 0] The radius\n\t * @param {Number} [scale = 1] The scale\n\t * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n\t * @returns {Circle}\n\t */\n\tcreateCircle(x = 0, y = 0, radius = 0, scale = 1, padding = 0) {\n\t\tconst body = new Circle(x, y, radius, scale, padding);\n\n\t\tthis._bvh.insert(body);\n\n\t\treturn body;\n\t}\n\n\t/**\n\t * Creates a {@link Polygon} and inserts it into the collision system\n\t * @param {Number} [x = 0] The starting X coordinate\n\t * @param {Number} [y = 0] The starting Y coordinate\n\t * @param {Array<Number[]>} [points = []] An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n\t * @param {Number} [angle = 0] The starting rotation in radians\n\t * @param {Number} [scale_x = 1] The starting scale along the X axis\n\t * @param {Number} [scale_y = 1] The starting scale long the Y axis\n\t * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n\t * @returns {Polygon}\n\t */\n\tcreatePolygon(x = 0, y = 0, points = [[0, 0]], angle = 0, scale_x = 1, scale_y = 1, padding = 0) {\n\t\tconst body = new Polygon(x, y, points, angle, scale_x, scale_y, padding);\n\n\t\tthis._bvh.insert(body);\n\n\t\treturn body;\n\t}\n\n\t/**\n\t * Creates a {@link Point} and inserts it into the collision system\n\t * @param {Number} [x = 0] The starting X coordinate\n\t * @param {Number} [y = 0] The starting Y coordinate\n\t * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n\t * @returns {Point}\n\t */\n\tcreatePoint(x = 0, y = 0, padding = 0) {\n\t\tconst body = new Point(x, y, padding);\n\n\t\tthis._bvh.insert(body);\n\n\t\treturn body;\n\t}\n\n\t/**\n\t * Creates a {@link Result} used to collect the detailed results of a collision test\n\t */\n\tcreateResult() {\n\t\treturn new Result();\n\t}\n\n\t/**\n\t * Creates a Result used to collect the detailed results of a collision test\n\t */\n\tstatic createResult() {\n\t\treturn new Result();\n\t}\n\n\t/**\n\t * Inserts bodies into the collision system\n\t * @param {...Circle|...Polygon|...Point} bodies\n\t */\n\tinsert(...bodies) {\n\t\tfor(const body of bodies) {\n\t\t\tthis._bvh.insert(body, false);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes bodies from the collision system\n\t * @param {...Circle|...Polygon|...Point} bodies\n\t */\n\tremove(...bodies) {\n\t\tfor(const body of bodies) {\n\t\t\tthis._bvh.remove(body, false);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Updates the collision system. This should be called before any collisions are tested.\n\t */\n\tupdate() {\n\t\tthis._bvh.update();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Draws the bodies within the system to a CanvasRenderingContext2D's current path\n\t * @param {CanvasRenderingContext2D} context The context to draw to\n\t */\n\tdraw(context) {\n\t\treturn this._bvh.draw(context);\n\t}\n\n\t/**\n\t * Draws the system's BVH to a CanvasRenderingContext2D's current path. This is useful for testing out different padding values for bodies.\n\t * @param {CanvasRenderingContext2D} context The context to draw to\n\t */\n\tdrawBVH(context) {\n\t\treturn this._bvh.drawBVH(context);\n\t}\n\n\t/**\n\t * Returns a list of potential collisions for a body\n\t * @param {Circle|Polygon|Point} body The body to test for potential collisions against\n\t * @returns {Array<Body>}\n\t */\n\tpotentials(body) {\n\t\treturn this._bvh.potentials(body);\n\t}\n\n\t/**\n\t * Determines if two bodies are colliding\n\t * @param {Circle|Polygon|Point} target The target body to test against\n\t * @param {Result} [result = null] A Result object on which to store information about the collision\n\t * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own potential collision heuristic)\n\t * @returns {Boolean}\n\t */\n\tcollides(source, target, result = null, aabb = true) {\n\t\treturn SAT(source, target, result, aabb);\n\t}\n};\n\nexport {\n\tCollisions as default,\n\tCollisions,\n\tResult,\n\tCircle,\n\tPolygon,\n\tPoint,\n};\n","import BVHBranch from './BVHBranch.mjs';\n\n/**\n * A Bounding Volume Hierarchy (BVH) used to find potential collisions quickly\n * @class\n * @private\n */\nexport default class BVH {\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\t/** @private */\n\t\tthis._hierarchy = null;\n\n\t\t/** @private */\n\t\tthis._bodies = [];\n\n\t\t/** @private */\n\t\tthis._dirty_branches = [];\n\t}\n\n\t/**\n\t * Inserts a body into the BVH\n\t * @param {Circle|Polygon|Point} body The body to insert\n\t * @param {Boolean} [updating = false] Set to true if the body already exists in the BVH (used internally when updating the body's position)\n\t */\n\tinsert(body, updating = false) {\n\t\tif(!updating) {\n\t\t\tconst bvh = body._bvh;\n\n\t\t\tif(bvh && bvh !== this) {\n\t\t\t\tthrow new Error('Body belongs to another collision system');\n\t\t\t}\n\n\t\t\tbody._bvh = this;\n\t\t\tthis._bodies.push(body);\n\t\t}\n\n\t\tconst polygon = body._polygon;\n\t\tconst body_x  = body.x;\n\t\tconst body_y  = body.y;\n\n\t\tif(polygon) {\n\t\t\tif(\n\t\t\t\tbody._dirty_coords ||\n\t\t\t\tbody.x       !== body._x ||\n\t\t\t\tbody.y       !== body._y ||\n\t\t\t\tbody.angle   !== body._angle ||\n\t\t\t\tbody.scale_x !== body._scale_x ||\n\t\t\t\tbody.scale_y !== body._scale_y\n\t\t\t) {\n\t\t\t\tbody._calculateCoords();\n\t\t\t}\n\t\t}\n\n\t\tconst padding    = body._bvh_padding;\n\t\tconst radius     = polygon ? 0 : body.radius * body.scale;\n\t\tconst body_min_x = (polygon ? body._min_x : body_x - radius) - padding;\n\t\tconst body_min_y = (polygon ? body._min_y : body_y - radius) - padding;\n\t\tconst body_max_x = (polygon ? body._max_x : body_x + radius) + padding;\n\t\tconst body_max_y = (polygon ? body._max_y : body_y + radius) + padding;\n\n\t\tbody._bvh_min_x = body_min_x;\n\t\tbody._bvh_min_y = body_min_y;\n\t\tbody._bvh_max_x = body_max_x;\n\t\tbody._bvh_max_y = body_max_y;\n\n\t\tlet current = this._hierarchy;\n\t\tlet sort    = 0;\n\n\t\tif(!current) {\n\t\t\tthis._hierarchy = body;\n\t\t}\n\t\telse {\n\t\t\twhile(true) {\n\t\t\t\t// Branch\n\t\t\t\tif(current._bvh_branch) {\n\t\t\t\t\tconst left            = current._bvh_left;\n\t\t\t\t\tconst left_min_y      = left._bvh_min_y;\n\t\t\t\t\tconst left_max_x      = left._bvh_max_x;\n\t\t\t\t\tconst left_max_y      = left._bvh_max_y;\n\t\t\t\t\tconst left_new_min_x  = body_min_x < left._bvh_min_x ? body_min_x : left._bvh_min_x;\n\t\t\t\t\tconst left_new_min_y  = body_min_y < left_min_y ? body_min_y : left_min_y;\n\t\t\t\t\tconst left_new_max_x  = body_max_x > left_max_x ? body_max_x : left_max_x;\n\t\t\t\t\tconst left_new_max_y  = body_max_y > left_max_y ? body_max_y : left_max_y;\n\t\t\t\t\tconst left_volume     = (left_max_x - left._bvh_min_x) * (left_max_y - left_min_y);\n\t\t\t\t\tconst left_new_volume = (left_new_max_x - left_new_min_x) * (left_new_max_y - left_new_min_y);\n\t\t\t\t\tconst left_difference = left_new_volume - left_volume;\n\n\t\t\t\t\tconst right            = current._bvh_right;\n\t\t\t\t\tconst right_min_x      = right._bvh_min_x;\n\t\t\t\t\tconst right_min_y      = right._bvh_min_y;\n\t\t\t\t\tconst right_max_x      = right._bvh_max_x;\n\t\t\t\t\tconst right_max_y      = right._bvh_max_y;\n\t\t\t\t\tconst right_new_min_x  = body_min_x < right_min_x ? body_min_x : right_min_x;\n\t\t\t\t\tconst right_new_min_y  = body_min_y < right_min_y ? body_min_y : right_min_y;\n\t\t\t\t\tconst right_new_max_x  = body_max_x > right_max_x ? body_max_x : right_max_x;\n\t\t\t\t\tconst right_new_max_y  = body_max_y > right_max_y ? body_max_y : right_max_y;\n\t\t\t\t\tconst right_volume     = (right_max_x - right_min_x) * (right_max_y - right_min_y);\n\t\t\t\t\tconst right_new_volume = (right_new_max_x - right_new_min_x) * (right_new_max_y - right_new_min_y);\n\t\t\t\t\tconst right_difference = right_new_volume - right_volume;\n\n\t\t\t\t\tcurrent._bvh_sort  = sort++;\n\t\t\t\t\tcurrent._bvh_min_x = left_new_min_x < right_new_min_x ? left_new_min_x : right_new_min_x;\n\t\t\t\t\tcurrent._bvh_min_y = left_new_min_y < right_new_min_y ? left_new_min_y : right_new_min_y;\n\t\t\t\t\tcurrent._bvh_max_x = left_new_max_x > right_new_max_x ? left_new_max_x : right_new_max_x;\n\t\t\t\t\tcurrent._bvh_max_y = left_new_max_y > right_new_max_y ? left_new_max_y : right_new_max_y;\n\n\t\t\t\t\tcurrent = left_difference <= right_difference ? left : right;\n\t\t\t\t}\n\t\t\t\t// Leaf\n\t\t\t\telse {\n\t\t\t\t\tconst grandparent  = current._bvh_parent;\n\t\t\t\t\tconst parent_min_x = current._bvh_min_x;\n\t\t\t\t\tconst parent_min_y = current._bvh_min_y;\n\t\t\t\t\tconst parent_max_x = current._bvh_max_x;\n\t\t\t\t\tconst parent_max_y = current._bvh_max_y;\n\t\t\t\t\tconst new_parent   = current._bvh_parent = body._bvh_parent = BVHBranch.getBranch();\n\n\t\t\t\t\tnew_parent._bvh_parent = grandparent;\n\t\t\t\t\tnew_parent._bvh_left   = current;\n\t\t\t\t\tnew_parent._bvh_right  = body;\n\t\t\t\t\tnew_parent._bvh_sort   = sort++;\n\t\t\t\t\tnew_parent._bvh_min_x  = body_min_x < parent_min_x ? body_min_x : parent_min_x;\n\t\t\t\t\tnew_parent._bvh_min_y  = body_min_y < parent_min_y ? body_min_y : parent_min_y;\n\t\t\t\t\tnew_parent._bvh_max_x  = body_max_x > parent_max_x ? body_max_x : parent_max_x;\n\t\t\t\t\tnew_parent._bvh_max_y  = body_max_y > parent_max_y ? body_max_y : parent_max_y;\n\n\t\t\t\t\tif(!grandparent) {\n\t\t\t\t\t\tthis._hierarchy = new_parent;\n\t\t\t\t\t}\n\t\t\t\t\telse if(grandparent._bvh_left === current) {\n\t\t\t\t\t\tgrandparent._bvh_left = new_parent;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tgrandparent._bvh_right = new_parent;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes a body from the BVH\n\t * @param {Circle|Polygon|Point} body The body to remove\n\t * @param {Boolean} [updating = false] Set to true if this is a temporary removal (used internally when updating the body's position)\n\t */\n\tremove(body, updating = false) {\n\t\tif(!updating) {\n\t\t\tconst bvh = body._bvh;\n\n\t\t\tif(bvh && bvh !== this) {\n\t\t\t\tthrow new Error('Body belongs to another collision system');\n\t\t\t}\n\n\t\t\tbody._bvh = null;\n\t\t\tthis._bodies.splice(this._bodies.indexOf(body), 1);\n\t\t}\n\n\t\tif(this._hierarchy === body) {\n\t\t\tthis._hierarchy = null;\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst parent       = body._bvh_parent;\n\t\tconst grandparent  = parent._bvh_parent;\n\t\tconst parent_left  = parent._bvh_left;\n\t\tconst sibling      = parent_left === body ? parent._bvh_right : parent_left;\n\n\t\tsibling._bvh_parent = grandparent;\n\n\t\tif(sibling._bvh_branch) {\n\t\t\tsibling._bvh_sort = parent._bvh_sort;\n\t\t}\n\n\t\tif(grandparent) {\n\t\t\tif(grandparent._bvh_left === parent) {\n\t\t\t\tgrandparent._bvh_left = sibling;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrandparent._bvh_right = sibling;\n\t\t\t}\n\n\t\t\tlet branch = grandparent;\n\n\t\t\twhile(branch) {\n\t\t\t\tconst left       = branch._bvh_left;\n\t\t\t\tconst left_min_x = left._bvh_min_x;\n\t\t\t\tconst left_min_y = left._bvh_min_y;\n\t\t\t\tconst left_max_x = left._bvh_max_x;\n\t\t\t\tconst left_max_y = left._bvh_max_y;\n\n\t\t\t\tconst right       = branch._bvh_right;\n\t\t\t\tconst right_min_x = right._bvh_min_x;\n\t\t\t\tconst right_min_y = right._bvh_min_y;\n\t\t\t\tconst right_max_x = right._bvh_max_x;\n\t\t\t\tconst right_max_y = right._bvh_max_y;\n\n\t\t\t\tbranch._bvh_min_x = left_min_x < right_min_x ? left_min_x : right_min_x;\n\t\t\t\tbranch._bvh_min_y = left_min_y < right_min_y ? left_min_y : right_min_y;\n\t\t\t\tbranch._bvh_max_x = left_max_x > right_max_x ? left_max_x : right_max_x;\n\t\t\t\tbranch._bvh_max_y = left_max_y > right_max_y ? left_max_y : right_max_y;\n\n\t\t\t\tbranch = branch._bvh_parent;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis._hierarchy = sibling;\n\t\t}\n\n\t\tBVHBranch.releaseBranch(parent);\n\t}\n\n\t/**\n\t * Updates the BVH. Moved bodies are removed/inserted.\n\t */\n\tupdate() {\n\t\tconst bodies = this._bodies;\n\t\tconst count  = bodies.length;\n\n\t\tfor(let i = 0; i < count; ++i) {\n\t\t\tconst body = bodies[i];\n\n\t\t\tlet update = false;\n\n\t\t\tif(!update && body.padding !== body._bvh_padding) {\n\t\t\t\tbody._bvh_padding = body.padding;\n\t\t\t\tupdate = true;\n\t\t\t}\n\n\t\t\tif(!update) {\n\t\t\t\tconst polygon = body._polygon;\n\n\t\t\t\tif(polygon) {\n\t\t\t\t\tif(\n\t\t\t\t\t\tbody._dirty_coords ||\n\t\t\t\t\t\tbody.x       !== body._x ||\n\t\t\t\t\t\tbody.y       !== body._y ||\n\t\t\t\t\t\tbody.angle   !== body._angle ||\n\t\t\t\t\t\tbody.scale_x !== body._scale_x ||\n\t\t\t\t\t\tbody.scale_y !== body._scale_y\n\t\t\t\t\t) {\n\t\t\t\t\t\tbody._calculateCoords();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst x      = body.x;\n\t\t\t\tconst y      = body.y;\n\t\t\t\tconst radius = polygon ? 0 : body.radius * body.scale;\n\t\t\t\tconst min_x  = polygon ? body._min_x : x - radius;\n\t\t\t\tconst min_y  = polygon ? body._min_y : y - radius;\n\t\t\t\tconst max_x  = polygon ? body._max_x : x + radius;\n\t\t\t\tconst max_y  = polygon ? body._max_y : y + radius;\n\n\t\t\t\tupdate = min_x < body._bvh_min_x || min_y < body._bvh_min_y || max_x > body._bvh_max_x || max_y > body._bvh_max_y;\n\t\t\t}\n\n\t\t\tif(update) {\n\t\t\t\tthis.remove(body, true);\n\t\t\t\tthis.insert(body, true);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of potential collisions for a body\n\t * @param {Circle|Polygon|Point} body The body to test\n\t * @returns {Array<Body>}\n\t */\n\tpotentials(body) {\n\t\tconst results = [];\n\t\tconst min_x   = body._bvh_min_x;\n\t\tconst min_y   = body._bvh_min_y;\n\t\tconst max_x   = body._bvh_max_x;\n\t\tconst max_y   = body._bvh_max_y;\n\n\t\tlet current       = this._hierarchy;\n\t\tlet traverse_left = true;\n\n\t\tif(!current || !current._bvh_branch) {\n\t\t\treturn results;\n\t\t}\n\n\t\twhile(current) {\n\t\t\tif(traverse_left) {\n\t\t\t\ttraverse_left = false;\n\n\t\t\t\tlet left = current._bvh_branch ? current._bvh_left : null;\n\n\t\t\t\twhile(\n\t\t\t\t\tleft &&\n\t\t\t\t\tleft._bvh_max_x >= min_x &&\n\t\t\t\t\tleft._bvh_max_y >= min_y &&\n\t\t\t\t\tleft._bvh_min_x <= max_x &&\n\t\t\t\t\tleft._bvh_min_y <= max_y\n\t\t\t\t) {\n\t\t\t\t\tcurrent = left;\n\t\t\t\t\tleft    = current._bvh_branch ? current._bvh_left : null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst branch = current._bvh_branch;\n\t\t\tconst right  = branch ? current._bvh_right : null;\n\n\t\t\tif(\n\t\t\t\tright &&\n\t\t\t\tright._bvh_max_x > min_x &&\n\t\t\t\tright._bvh_max_y > min_y &&\n\t\t\t\tright._bvh_min_x < max_x &&\n\t\t\t\tright._bvh_min_y < max_y\n\t\t\t) {\n\t\t\t\tcurrent       = right;\n\t\t\t\ttraverse_left = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(!branch && current !== body) {\n\t\t\t\t\tresults.push(current);\n\t\t\t\t}\n\n\t\t\t\tlet parent = current._bvh_parent;\n\n\t\t\t\tif(parent) {\n\t\t\t\t\twhile(parent && parent._bvh_right === current) {\n\t\t\t\t\t\tcurrent = parent;\n\t\t\t\t\t\tparent  = current._bvh_parent;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent = parent;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Draws the bodies within the BVH to a CanvasRenderingContext2D's current path\n\t * @param {CanvasRenderingContext2D} context The context to draw to\n\t */\n\tdraw(context) {\n\t\tconst bodies = this._bodies;\n\t\tconst count  = bodies.length;\n\n\t\tfor(let i = 0; i < count; ++i) {\n\t\t\tbodies[i].draw(context);\n\t\t}\n\t}\n\n\t/**\n\t * Draws the BVH to a CanvasRenderingContext2D's current path. This is useful for testing out different padding values for bodies.\n\t * @param {CanvasRenderingContext2D} context The context to draw to\n\t */\n\tdrawBVH(context) {\n\t\tlet current       = this._hierarchy;\n\t\tlet traverse_left = true;\n\n\t\twhile(current) {\n\t\t\tif(traverse_left) {\n\t\t\t\ttraverse_left = false;\n\n\t\t\t\tlet left = current._bvh_branch ? current._bvh_left : null;\n\n\t\t\t\twhile(left) {\n\t\t\t\t\tcurrent = left;\n\t\t\t\t\tleft    = current._bvh_branch ? current._bvh_left : null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst branch = current._bvh_branch;\n\t\t\tconst min_x  = current._bvh_min_x;\n\t\t\tconst min_y  = current._bvh_min_y;\n\t\t\tconst max_x  = current._bvh_max_x;\n\t\t\tconst max_y  = current._bvh_max_y;\n\t\t\tconst right  = branch ? current._bvh_right : null;\n\n\t\t\tcontext.moveTo(min_x, min_y);\n\t\t\tcontext.lineTo(max_x, min_y);\n\t\t\tcontext.lineTo(max_x, max_y);\n\t\t\tcontext.lineTo(min_x, max_y);\n\t\t\tcontext.lineTo(min_x, min_y);\n\n\t\t\tif(right) {\n\t\t\t\tcurrent       = right;\n\t\t\t\ttraverse_left = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet parent = current._bvh_parent;\n\n\t\t\t\tif(parent) {\n\t\t\t\t\twhile(parent && parent._bvh_right === current) {\n\t\t\t\t\t\tcurrent = parent;\n\t\t\t\t\t\tparent  = current._bvh_parent;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent = parent;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n","/**\n * @private\n */\nconst branch_pool = [];\n\n/**\n * A branch within a BVH\n * @class\n * @private\n */\nexport default class BVHBranch {\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\t/** @private */\n\t\tthis._bvh_parent = null;\n\n\t\t/** @private */\n\t\tthis._bvh_branch = true;\n\n\t\t/** @private */\n\t\tthis._bvh_left = null;\n\n\t\t/** @private */\n\t\tthis._bvh_right = null;\n\n\t\t/** @private */\n\t\tthis._bvh_sort = 0;\n\n\t\t/** @private */\n\t\tthis._bvh_min_x = 0;\n\n\t\t/** @private */\n\t\tthis._bvh_min_y = 0;\n\n\t\t/** @private */\n\t\tthis._bvh_max_x = 0;\n\n\t\t/** @private */\n\t\tthis._bvh_max_y = 0;\n\t}\n\n\t/**\n\t * Returns a branch from the branch pool or creates a new branch\n\t * @returns {BVHBranch}\n\t */\n\tstatic getBranch() {\n\t\tif(branch_pool.length) {\n\t\t\treturn branch_pool.pop();\n\t\t}\n\n\t\treturn new BVHBranch();\n\t}\n\n\t/**\n\t * Releases a branch back into the branch pool\n\t * @param {BVHBranch} branch The branch to release\n\t */\n\tstatic releaseBranch(branch) {\n\t\tbranch_pool.push(branch);\n\t}\n\n\t/**\n\t * Sorting callback used to sort branches by deepest first\n\t * @param {BVHBranch} a The first branch\n\t * @param {BVHBranch} b The second branch\n\t * @returns {Number}\n\t */\n\tstatic sortBranches(a, b) {\n\t\treturn a.sort > b.sort ? -1 : 1;\n\t}\n};\n","import Result from './Result.mjs';\nimport SAT    from './SAT.mjs';\n\n/**\n * The base class for bodies used to detect collisions\n * @class\n * @protected\n */\nexport default class Body {\n\t/**\n\t * @constructor\n\t * @param {Number} [x = 0] The starting X coordinate\n\t * @param {Number} [y = 0] The starting Y coordinate\n\t * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n\t */\n\tconstructor(x = 0, y = 0, padding = 0) {\n\t\t/**\n\t\t * @desc The X coordinate of the body\n\t\t * @type {Number}\n\t\t */\n\t\tthis.x = x;\n\n\t\t/**\n\t\t * @desc The Y coordinate of the body\n\t\t * @type {Number}\n\t\t */\n\t\tthis.y = y;\n\n\t\t/**\n\t\t * @desc The amount to pad the bounding volume when testing for potential collisions\n\t\t * @type {Number}\n\t\t */\n\t\tthis.padding = padding;\n\n\t\t/** @private */\n\t\tthis._circle = false;\n\n\t\t/** @private */\n\t\tthis._polygon = false;\n\n\t\t/** @private */\n\t\tthis._point = false;\n\n\t\t/** @private */\n\t\tthis._bvh = null;\n\n\t\t/** @private */\n\t\tthis._bvh_parent = null;\n\n\t\t/** @private */\n\t\tthis._bvh_branch = false;\n\n\t\t/** @private */\n\t\tthis._bvh_padding = padding;\n\n\t\t/** @private */\n\t\tthis._bvh_min_x = 0;\n\n\t\t/** @private */\n\t\tthis._bvh_min_y = 0;\n\n\t\t/** @private */\n\t\tthis._bvh_max_x = 0;\n\n\t\t/** @private */\n\t\tthis._bvh_max_y = 0;\n\t}\n\n\t/**\n\t * Determines if the body is colliding with another body\n\t * @param {Circle|Polygon|Point} target The target body to test against\n\t * @param {Result} [result = null] A Result object on which to store information about the collision\n\t * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own potential collision heuristic)\n\t * @returns {Boolean}\n\t */\n\tcollides(target, result = null, aabb = true) {\n\t\treturn SAT(this, target, result, aabb);\n\t}\n\n\t/**\n\t * Returns a list of potential collisions\n\t * @returns {Array<Body>}\n\t */\n\tpotentials() {\n\t\tconst bvh = this._bvh;\n\n\t\tif(bvh === null) {\n\t\t\tthrow new Error('Body does not belong to a collision system');\n\t\t}\n\n\t\treturn bvh.potentials(this);\n\t}\n\n\t/**\n\t * Removes the body from its current collision system\n\t */\n\tremove() {\n\t\tconst bvh = this._bvh;\n\n\t\tif(bvh) {\n\t\t\tbvh.remove(this, false);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} used to collect the detailed results of a collision test\n\t */\n\tcreateResult() {\n\t\treturn new Result();\n\t}\n\n\t/**\n\t * Creates a Result used to collect the detailed results of a collision test\n\t */\n\tstatic createResult() {\n\t\treturn new Result();\n\t}\n};\n","import Body from './Body.mjs';\n\n/**\n * A circle used to detect collisions\n * @class\n */\nexport default class Circle extends Body {\n\t/**\n\t * @constructor\n\t * @param {Number} [x = 0] The starting X coordinate\n\t * @param {Number} [y = 0] The starting Y coordinate\n\t * @param {Number} [radius = 0] The radius\n\t * @param {Number} [scale = 1] The scale\n\t * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n\t */\n\tconstructor(x = 0, y = 0, radius = 0, scale = 1, padding = 0) {\n\t\tsuper(x, y, padding);\n\n\t\t/**\n\t\t * @desc\n\t\t * @type {Number}\n\t\t */\n\t\tthis.radius = radius;\n\n\t\t/**\n\t\t * @desc\n\t\t * @type {Number}\n\t\t */\n\t\tthis.scale = scale;\n\t}\n\n\t/**\n\t * Draws the circle to a CanvasRenderingContext2D's current path\n\t * @param {CanvasRenderingContext2D} context The context to add the arc to\n\t */\n\tdraw(context) {\n\t\tconst x      = this.x;\n\t\tconst y      = this.y;\n\t\tconst radius = this.radius * this.scale;\n\n\t\tcontext.moveTo(x + radius, y);\n\t\tcontext.arc(x, y, radius, 0, Math.PI * 2);\n\t}\n};\n","import Polygon from './Polygon.mjs';\n\n/**\n * A point used to detect collisions\n * @class\n */\nexport default class Point extends Polygon {\n\t/**\n\t * @constructor\n\t * @param {Number} [x = 0] The starting X coordinate\n\t * @param {Number} [y = 0] The starting Y coordinate\n\t * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n\t */\n\tconstructor(x = 0, y = 0, padding = 0) {\n\t\tsuper(x, y, [[0, 0]], 0, 1, 1, padding);\n\n\t\t/** @private */\n\t\tthis._point = true;\n\t}\n};\n\nPoint.prototype.setPoints = undefined;\n","import Body from './Body.mjs';\n\n/**\n * A polygon used to detect collisions\n * @class\n */\nexport default class Polygon extends Body {\n\t/**\n\t * @constructor\n\t * @param {Number} [x = 0] The starting X coordinate\n\t * @param {Number} [y = 0] The starting Y coordinate\n\t * @param {Array<Number[]>} [points = []] An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n\t * @param {Number} [angle = 0] The starting rotation in radians\n\t * @param {Number} [scale_x = 1] The starting scale along the X axis\n\t * @param {Number} [scale_y = 1] The starting scale long the Y axis\n\t * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n\t */\n\tconstructor(x = 0, y = 0, points = [], angle = 0, scale_x = 1, scale_y = 1, padding = 0) {\n\t\tsuper(x, y, padding);\n\n\t\t/**\n\t\t * @desc The angle of the body in radians\n\t\t * @type {Number}\n\t\t */\n\t\tthis.angle = angle;\n\n\t\t/**\n\t\t * @desc The scale of the body along the X axis\n\t\t * @type {Number}\n\t\t */\n\t\tthis.scale_x = scale_x;\n\n\t\t/**\n\t\t * @desc The scale of the body along the Y axis\n\t\t * @type {Number}\n\t\t */\n\t\tthis.scale_y = scale_y;\n\n\n\t\t/** @private */\n\t\tthis._polygon = true;\n\n\t\t/** @private */\n\t\tthis._x = x;\n\n\t\t/** @private */\n\t\tthis._y = y;\n\n\t\t/** @private */\n\t\tthis._angle = angle;\n\n\t\t/** @private */\n\t\tthis._scale_x = scale_x;\n\n\t\t/** @private */\n\t\tthis._scale_y = scale_y;\n\n\t\t/** @private */\n\t\tthis._min_x = 0;\n\n\t\t/** @private */\n\t\tthis._min_y = 0;\n\n\t\t/** @private */\n\t\tthis._max_x = 0;\n\n\t\t/** @private */\n\t\tthis._max_y = 0;\n\n\t\t/** @private */\n\t\tthis._points = null;\n\n\t\t/** @private */\n\t\tthis._coords = null;\n\n\t\t/** @private */\n\t\tthis._edges = null;\n\n\t\t/** @private */\n\t\tthis._normals = null;\n\n\t\t/** @private */\n\t\tthis._dirty_coords = true;\n\n\t\t/** @private */\n\t\tthis._dirty_normals = true;\n\n\t\tPolygon.prototype.setPoints.call(this, points);\n\t}\n\n\t/**\n\t * Draws the polygon to a CanvasRenderingContext2D's current path\n\t * @param {CanvasRenderingContext2D} context The context to add the shape to\n\t */\n\tdraw(context) {\n\t\tif(\n\t\t\tthis._dirty_coords ||\n\t\t\tthis.x       !== this._x ||\n\t\t\tthis.y       !== this._y ||\n\t\t\tthis.angle   !== this._angle ||\n\t\t\tthis.scale_x !== this._scale_x ||\n\t\t\tthis.scale_y !== this._scale_y\n\t\t) {\n\t\t\tthis._calculateCoords();\n\t\t}\n\n\t\tconst coords = this._coords;\n\n\t\tif(coords.length === 2) {\n\t\t\tcontext.moveTo(coords[0], coords[1]);\n\t\t\tcontext.arc(coords[0], coords[1], 1, 0, Math.PI * 2);\n\t\t}\n\t\telse {\n\t\t\tcontext.moveTo(coords[0], coords[1]);\n\n\t\t\tfor(let i = 2; i < coords.length; i += 2) {\n\t\t\t\tcontext.lineTo(coords[i], coords[i + 1]);\n\t\t\t}\n\n\t\t\tif(coords.length > 4) {\n\t\t\t\tcontext.lineTo(coords[0], coords[1]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Sets the points making up the polygon. It's important to use this function when changing the polygon's shape to ensure internal data is also updated.\n\t * @param {Array<Number[]>} new_points An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n\t */\n\tsetPoints(new_points) {\n\t\tconst count = new_points.length;\n\n\t\tthis._points  = new Float64Array(count * 2);\n\t\tthis._coords  = new Float64Array(count * 2);\n\t\tthis._edges   = new Float64Array(count * 2);\n\t\tthis._normals = new Float64Array(count * 2);\n\n\t\tconst points = this._points;\n\n\t\tfor(let i = 0, ix = 0, iy = 1; i < count; ++i, ix += 2, iy += 2) {\n\t\t\tconst new_point = new_points[i];\n\n\t\t\tpoints[ix] = new_point[0];\n\t\t\tpoints[iy] = new_point[1];\n\t\t}\n\n\t\tthis._dirty_coords = true;\n\t}\n\n\t/**\n\t * Calculates and caches the polygon's world coordinates based on its points, angle, and scale\n\t */\n\t_calculateCoords() {\n\t\tconst x       = this.x;\n\t\tconst y       = this.y;\n\t\tconst angle   = this.angle;\n\t\tconst scale_x = this.scale_x;\n\t\tconst scale_y = this.scale_y;\n\t\tconst points  = this._points;\n\t\tconst coords  = this._coords;\n\t\tconst count   = points.length;\n\n\t\tlet min_x;\n\t\tlet max_x;\n\t\tlet min_y;\n\t\tlet max_y;\n\n\t\tfor(let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n\t\t\tlet coord_x = points[ix] * scale_x;\n\t\t\tlet coord_y = points[iy] * scale_y;\n\n\t\t\tif(angle) {\n\t\t\t\tconst cos   = Math.cos(angle);\n\t\t\t\tconst sin   = Math.sin(angle);\n\t\t\t\tconst tmp_x = coord_x;\n\t\t\t\tconst tmp_y = coord_y;\n\n\t\t\t\tcoord_x = tmp_x * cos - tmp_y * sin;\n\t\t\t\tcoord_y = tmp_x * sin + tmp_y * cos;\n\t\t\t}\n\n\t\t\tcoord_x += x;\n\t\t\tcoord_y += y;\n\n\t\t\tcoords[ix] = coord_x;\n\t\t\tcoords[iy] = coord_y;\n\n\t\t\tif(ix === 0) {\n\t\t\t\tmin_x = max_x = coord_x;\n\t\t\t\tmin_y = max_y = coord_y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(coord_x < min_x) {\n\t\t\t\t\tmin_x = coord_x;\n\t\t\t\t}\n\t\t\t\telse if(coord_x > max_x) {\n\t\t\t\t\tmax_x = coord_x;\n\t\t\t\t}\n\n\t\t\t\tif(coord_y < min_y) {\n\t\t\t\t\tmin_y = coord_y;\n\t\t\t\t}\n\t\t\t\telse if(coord_y > max_y) {\n\t\t\t\t\tmax_y = coord_y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._x             = x;\n\t\tthis._y             = y;\n\t\tthis._angle         = angle;\n\t\tthis._scale_x       = scale_x;\n\t\tthis._scale_y       = scale_y;\n\t\tthis._min_x         = min_x;\n\t\tthis._min_y         = min_y;\n\t\tthis._max_x         = max_x;\n\t\tthis._max_y         = max_y;\n\t\tthis._dirty_coords  = false;\n\t\tthis._dirty_normals = true;\n\t}\n\n\t/**\n\t * Calculates the normals and edges of the polygon's sides\n\t */\n\t_calculateNormals() {\n\t\tconst coords  = this._coords;\n\t\tconst edges   = this._edges;\n\t\tconst normals = this._normals;\n\t\tconst count   = coords.length;\n\n\t\tfor(let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n\t\t\tconst next   = ix + 2 < count ? ix + 2 : 0;\n\t\t\tconst x      = coords[next] - coords[ix];\n\t\t\tconst y      = coords[next + 1] - coords[iy];\n\t\t\tconst length = x || y ? Math.sqrt(x * x + y * y) : 0;\n\n\t\t\tedges[ix]   = x;\n\t\t\tedges[iy]   = y;\n\t\t\tnormals[ix] = length ? y / length : 0;\n\t\t\tnormals[iy] = length ? -x / length : 0;\n\t\t}\n\n\t\tthis._dirty_normals = false;\n\t}\n};\n","/**\n * An object used to collect the detailed results of a collision test\n *\n * > **Note:** It is highly recommended you recycle the same Result object if possible in order to avoid wasting memory\n * @class\n */\nexport default class Result {\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * @desc True if a collision was detected\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.collision = false;\n\n\t\t/**\n\t\t * @desc The source body tested\n\t\t * @type {Circle|Polygon|Point}\n\t\t */\n\t\tthis.a = null;\n\n\t\t/**\n\t\t * @desc The target body tested against\n\t\t * @type {Circle|Polygon|Point}\n\t\t */\n\t\tthis.b = null;\n\n\t\t/**\n\t\t * @desc True if A is completely contained within B\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.a_in_b = false;\n\n\t\t/**\n\t\t * @desc True if B is completely contained within A\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.a_in_b = false;\n\n\t\t/**\n\t\t * @desc The magnitude of the shortest axis of overlap\n\t\t * @type {Number}\n\t\t */\n\t\tthis.overlap = 0;\n\n\t\t/**\n\t\t * @desc The X direction of the shortest axis of overlap\n\t\t * @type {Number}\n\t\t */\n\t\tthis.overlap_x = 0;\n\n\t\t/**\n\t\t * @desc The Y direction of the shortest axis of overlap\n\t\t * @type {Number}\n\t\t */\n\t\tthis.overlap_y = 0;\n\t}\n};\n","/**\n * Determines if two bodies are colliding using the Separating Axis Theorem\n * @private\n * @param {Circle|Polygon|Point} a The source body to test\n * @param {Circle|Polygon|Point} b The target body to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own collision heuristic)\n * @returns {Boolean}\n */\nexport default function SAT(a, b, result = null, aabb = true) {\n\tconst a_polygon = a._polygon;\n\tconst b_polygon = b._polygon;\n\n\tlet collision = false;\n\n\tif(result) {\n\t\tresult.a         = a;\n\t\tresult.b         = b;\n\t\tresult.a_in_b    = true;\n\t\tresult.b_in_a    = true;\n\t\tresult.overlap   = null;\n\t\tresult.overlap_x = 0;\n\t\tresult.overlap_y = 0;\n\t}\n\n\tif(a_polygon) {\n\t\tif(\n\t\t\ta._dirty_coords ||\n\t\t\ta.x       !== a._x ||\n\t\t\ta.y       !== a._y ||\n\t\t\ta.angle   !== a._angle ||\n\t\t\ta.scale_x !== a._scale_x ||\n\t\t\ta.scale_y !== a._scale_y\n\t\t) {\n\t\t\ta._calculateCoords();\n\t\t}\n\t}\n\n\tif(b_polygon) {\n\t\tif(\n\t\t\tb._dirty_coords ||\n\t\t\tb.x       !== b._x ||\n\t\t\tb.y       !== b._y ||\n\t\t\tb.angle   !== b._angle ||\n\t\t\tb.scale_x !== b._scale_x ||\n\t\t\tb.scale_y !== b._scale_y\n\t\t) {\n\t\t\tb._calculateCoords();\n\t\t}\n\t}\n\n\tif(!aabb || aabbAABB(a, b)) {\n\t\tif(a_polygon && a._dirty_normals) {\n\t\t\ta._calculateNormals();\n\t\t}\n\n\t\tif(b_polygon && b._dirty_normals) {\n\t\t\tb._calculateNormals();\n\t\t}\n\n\t\tcollision = (\n\t\t\ta_polygon && b_polygon ? polygonPolygon(a, b, result) :\n\t\t\ta_polygon ? polygonCircle(a, b, result, false) :\n\t\t\tb_polygon ? polygonCircle(b, a, result, true) :\n\t\t\tcircleCircle(a, b, result)\n\t\t);\n\t}\n\n\tif(result) {\n\t\tresult.collision = collision;\n\t}\n\n\treturn collision;\n};\n\n/**\n * Determines if two bodies' axis aligned bounding boxes are colliding\n * @param {Circle|Polygon|Point} a The source body to test\n * @param {Circle|Polygon|Point} b The target body to test against\n */\nfunction aabbAABB(a, b) {\n\tconst a_polygon = a._polygon;\n\tconst a_x       = a_polygon ? 0 : a.x;\n\tconst a_y       = a_polygon ? 0 : a.y;\n\tconst a_radius  = a_polygon ? 0 : a.radius * a.scale;\n\tconst a_min_x   = a_polygon ? a._min_x : a_x - a_radius;\n\tconst a_min_y   = a_polygon ? a._min_y : a_y - a_radius;\n\tconst a_max_x   = a_polygon ? a._max_x : a_x + a_radius;\n\tconst a_max_y   = a_polygon ? a._max_y : a_y + a_radius;\n\n\tconst b_polygon = b._polygon;\n\tconst b_x       = b_polygon ? 0 : b.x;\n\tconst b_y       = b_polygon ? 0 : b.y;\n\tconst b_radius  = b_polygon ? 0 : b.radius * b.scale;\n\tconst b_min_x   = b_polygon ? b._min_x : b_x - b_radius;\n\tconst b_min_y   = b_polygon ? b._min_y : b_y - b_radius;\n\tconst b_max_x   = b_polygon ? b._max_x : b_x + b_radius;\n\tconst b_max_y   = b_polygon ? b._max_y : b_y + b_radius;\n\n\treturn a_min_x < b_max_x && a_min_y < b_max_y && a_max_x > b_min_x && a_max_y > b_min_y;\n}\n\n/**\n * Determines if two polygons are colliding\n * @param {Polygon} a The source polygon to test\n * @param {Polygon} b The target polygon to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nfunction polygonPolygon(a, b, result = null) {\n\tconst a_count = a._coords.length;\n\tconst b_count = b._coords.length;\n\n\t// Handle points specially\n\tif(a_count === 2 && b_count === 2) {\n\t\tconst a_coords = a._coords;\n\t\tconst b_coords = b._coords;\n\n\t\tif(result) {\n\t\t\tresult.overlap = 0;\n\t\t}\n\n\t\treturn a_coords[0] === b_coords[0] && a_coords[1] === b_coords[1];\n\t}\n\n\tconst a_coords  = a._coords;\n\tconst b_coords  = b._coords;\n\tconst a_normals = a._normals;\n\tconst b_normals = b._normals;\n\n\tif(a_count > 2) {\n\t\tfor(let ix = 0, iy = 1; ix < a_count; ix += 2, iy += 2) {\n\t\t\tif(separatingAxis(a_coords, b_coords, a_normals[ix], a_normals[iy], result)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(b_count > 2) {\n\t\tfor(let ix = 0, iy = 1; ix < b_count; ix += 2, iy += 2) {\n\t\t\tif(separatingAxis(a_coords, b_coords, b_normals[ix], b_normals[iy], result)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Determines if a polygon and a circle are colliding\n * @param {Polygon} a The source polygon to test\n * @param {Circle} b The target circle to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @param {Boolean} [reverse = false] Set to true to reverse a and b in the result parameter when testing circle->polygon instead of polygon->circle\n * @returns {Boolean}\n */\nfunction polygonCircle(a, b, result = null, reverse = false) {\n\tconst a_coords       = a._coords;\n\tconst a_edges        = a._edges;\n\tconst a_normals      = a._normals;\n\tconst b_x            = b.x;\n\tconst b_y            = b.y;\n\tconst b_radius       = b.radius * b.scale;\n\tconst b_radius2      = b_radius * 2;\n\tconst radius_squared = b_radius * b_radius;\n\tconst count          = a_coords.length;\n\n\tlet a_in_b    = true;\n\tlet b_in_a    = true;\n\tlet overlap   = null;\n\tlet overlap_x = 0;\n\tlet overlap_y = 0;\n\n\t// Handle points specially\n\tif(count === 2) {\n\t\tconst coord_x        = b_x - a_coords[0];\n\t\tconst coord_y        = b_y - a_coords[1];\n\t\tconst length_squared = coord_x * coord_x + coord_y * coord_y;\n\n\t\tif(length_squared > radius_squared) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif(result) {\n\t\t\tconst length = Math.sqrt(length_squared);\n\n\t\t\toverlap   = b_radius - length;\n\t\t\toverlap_x = coord_x / length;\n\t\t\toverlap_y = coord_y / length;\n\t\t\tb_in_a    = false;\n\t\t}\n\t}\n\telse {\n\t\tfor(let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n\t\t\tconst coord_x = b_x - a_coords[ix];\n\t\t\tconst coord_y = b_y - a_coords[iy];\n\t\t\tconst edge_x  = a_edges[ix];\n\t\t\tconst edge_y  = a_edges[iy];\n\t\t\tconst dot     = coord_x * edge_x + coord_y * edge_y;\n\t\t\tconst region  = dot < 0 ? -1 : dot > edge_x * edge_x + edge_y * edge_y ? 1 : 0;\n\n\t\t\tlet tmp_overlapping = false;\n\t\t\tlet tmp_overlap     = 0;\n\t\t\tlet tmp_overlap_x   = 0;\n\t\t\tlet tmp_overlap_y   = 0;\n\n\t\t\tif(result && a_in_b && coord_x * coord_x + coord_y * coord_y > radius_squared) {\n\t\t\t\ta_in_b = false;\n\t\t\t}\n\n\t\t\tif(region) {\n\t\t\t\tconst left     = region === -1;\n\t\t\t\tconst other_x  = left ? (ix === 0 ? count - 2 : ix - 2) : (ix === count - 2 ? 0 : ix + 2);\n\t\t\t\tconst other_y  = other_x + 1;\n\t\t\t\tconst coord2_x = b_x - a_coords[other_x];\n\t\t\t\tconst coord2_y = b_y - a_coords[other_y];\n\t\t\t\tconst edge2_x  = a_edges[other_x];\n\t\t\t\tconst edge2_y  = a_edges[other_y];\n\t\t\t\tconst dot2     = coord2_x * edge2_x + coord2_y * edge2_y;\n\t\t\t\tconst region2  = dot2 < 0 ? -1 : dot2 > edge2_x * edge2_x + edge2_y * edge2_y ? 1 : 0;\n\n\t\t\t\tif(region2 === -region) {\n\t\t\t\t\tconst target_x       = left ? coord_x : coord2_x;\n\t\t\t\t\tconst target_y       = left ? coord_y : coord2_y;\n\t\t\t\t\tconst length_squared = target_x * target_x + target_y * target_y;\n\n\t\t\t\t\tif(length_squared > radius_squared) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(result) {\n\t\t\t\t\t\tconst length = Math.sqrt(length_squared);\n\n\t\t\t\t\t\ttmp_overlapping = true;\n\t\t\t\t\t\ttmp_overlap     = b_radius - length;\n\t\t\t\t\t\ttmp_overlap_x   = target_x / length;\n\t\t\t\t\t\ttmp_overlap_y   = target_y / length;\n\t\t\t\t\t\tb_in_a          = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst normal_x        = a_normals[ix];\n\t\t\t\tconst normal_y        = a_normals[iy];\n\t\t\t\tconst length          = coord_x * normal_x + coord_y * normal_y;\n\t\t\t\tconst absolute_length = length < 0 ? -length : length;\n\n\t\t\t\tif(length > 0 && absolute_length > b_radius) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif(result) {\n\t\t\t\t\ttmp_overlapping = true;\n\t\t\t\t\ttmp_overlap     = b_radius - length;\n\t\t\t\t\ttmp_overlap_x   = normal_x;\n\t\t\t\t\ttmp_overlap_y   = normal_y;\n\n\t\t\t\t\tif(b_in_a && length >= 0 || tmp_overlap < b_radius2) {\n\t\t\t\t\t\tb_in_a = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(tmp_overlapping && (overlap === null || overlap > tmp_overlap)) {\n\t\t\t\toverlap   = tmp_overlap;\n\t\t\t\toverlap_x = tmp_overlap_x;\n\t\t\t\toverlap_y = tmp_overlap_y;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(result) {\n\t\tresult.a_in_b    = reverse ? b_in_a : a_in_b;\n\t\tresult.b_in_a    = reverse ? a_in_b : b_in_a;\n\t\tresult.overlap   = overlap;\n\t\tresult.overlap_x = reverse ? -overlap_x : overlap_x;\n\t\tresult.overlap_y = reverse ? -overlap_y : overlap_y;\n\t}\n\n\treturn true;\n}\n\n/**\n * Determines if two circles are colliding\n * @param {Circle} a The source circle to test\n * @param {Circle} b The target circle to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nfunction circleCircle(a, b, result = null) {\n\tconst a_radius       = a.radius * a.scale;\n\tconst b_radius       = b.radius * b.scale;\n\tconst difference_x   = b.x - a.x;\n\tconst difference_y   = b.y - a.y;\n\tconst radius_sum     = a_radius + b_radius;\n\tconst length_squared = difference_x * difference_x + difference_y * difference_y;\n\n\tif(length_squared > radius_sum * radius_sum) {\n\t\treturn false;\n\t}\n\n\tif(result) {\n\t\tconst length = Math.sqrt(length_squared);\n\n\t\tresult.a_in_b    = a_radius <= b_radius && length <= b_radius - a_radius;\n\t\tresult.b_in_a    = b_radius <= a_radius && length <= a_radius - b_radius;\n\t\tresult.overlap   = radius_sum - length;\n\t\tresult.overlap_x = difference_x / length;\n\t\tresult.overlap_y = difference_y / length;\n\t}\n\n\treturn true;\n}\n\n/**\n * Determines if two polygons are separated by an axis\n * @param {Array<Number[]>} a_coords The coordinates of the polygon to test\n * @param {Array<Number[]>} b_coords The coordinates of the polygon to test against\n * @param {Number} x The X direction of the axis\n * @param {Number} y The Y direction of the axis\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nfunction separatingAxis(a_coords, b_coords, x, y, result = null) {\n\tconst a_count = a_coords.length;\n\tconst b_count = b_coords.length;\n\n\tif(!a_count || !b_count) {\n\t\treturn true;\n\t}\n\n\tlet a_start = null;\n\tlet a_end   = null;\n\tlet b_start = null;\n\tlet b_end   = null;\n\n\tfor(let ix = 0, iy = 1; ix < a_count; ix += 2, iy += 2) {\n\t\tconst dot = a_coords[ix] * x + a_coords[iy] * y;\n\n\t\tif(a_start === null || a_start > dot) {\n\t\t\ta_start = dot;\n\t\t}\n\n\t\tif(a_end === null || a_end < dot) {\n\t\t\ta_end = dot;\n\t\t}\n\t}\n\n\tfor(let ix = 0, iy = 1; ix < b_count; ix += 2, iy += 2) {\n\t\tconst dot = b_coords[ix] * x + b_coords[iy] * y;\n\n\t\tif(b_start === null || b_start > dot) {\n\t\t\tb_start = dot;\n\t\t}\n\n\t\tif(b_end === null || b_end < dot) {\n\t\t\tb_end = dot;\n\t\t}\n\t}\n\n\tif(a_start > b_end || a_end < b_start) {\n\t\treturn true;\n\t}\n\n\tif(result) {\n\t\tlet overlap = 0;\n\n\t\tif(a_start < b_start) {\n\t\t\tresult.a_in_b = false;\n\n\t\t\tif(a_end < b_end) {\n\t\t\t\toverlap       = a_end - b_start;\n\t\t\t\tresult.b_in_a = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst option1 = a_end - b_start;\n\t\t\t\tconst option2 = b_end - a_start;\n\n\t\t\t\toverlap = option1 < option2 ? option1 : -option2;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tresult.b_in_a = false;\n\n\t\t\tif(a_end > b_end) {\n\t\t\t\toverlap       = a_start - b_end;\n\t\t\t\tresult.a_in_b = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst option1 = a_end - b_start;\n\t\t\t\tconst option2 = b_end - a_start;\n\n\t\t\t\toverlap = option1 < option2 ? option1 : -option2;\n\t\t\t}\n\t\t}\n\n\t\tconst current_overlap  = result.overlap;\n\t\tconst absolute_overlap = overlap < 0 ? -overlap : overlap;\n\n\t\tif(current_overlap === null || current_overlap > absolute_overlap) {\n\t\t\tconst sign = overlap < 0 ? -1 : 1;\n\n\t\t\tresult.overlap   = absolute_overlap;\n\t\t\tresult.overlap_x = x * sign;\n\t\t\tresult.overlap_y = y * sign;\n\t\t}\n\t}\n\n\treturn false;\n}\n","// import utils from './utils'\n// import { log } from 'util';\nimport Collisions from 'collisions';\n// Create the collision system\nconst collision = new Collisions();\n\n// Create a Result object for collecting information about the collisions\nconst collResult = collision.createResult();\n\n\n// -----------------------------------------------------------\n// -----------------------------------------------------------\n// -----------------------------------------------------------\n// -----------------------------------------------------------\n\n//Aliases\nconst Application = PIXI.Application,\n    loader = PIXI.loader,\n    resources = PIXI.loader.resources,\n    Sprite = PIXI.Sprite,\n    TextureCache = PIXI.utils.TextureCache,\n    Rectangle = PIXI.Rectangle;\n\nconst app = new Application({\n    width: 1920,\n    height: 1024,\n    resolution: 1\n});\n\nvar graphics2 = new PIXI.Graphics();\n\n// Create the player (represented by a Circle)\nconst collPlayer = collision.createPolygon(0, 0, [[0,0], [78,0], [78,78], [0,78]]);\n\n// Create some walls (represented by Polygons)\n// const wall1 = collision.createPolygon(400, 500, [[-60, -20], [60, -20], [60, 20], [-60, 20]], 1.7);\nconst wall4 = collision.createPolygon(0,0,[[350,700], [500,700], [425, 600]]);\nconst line = collision.createPolygon(0, app.renderer.height, [[0, 0], [app.renderer.width, 0]]);\n// Update the collision system\ncollision.update();\n\n\n// laod background\nloader.add('background', '/img/teamfun/Background2.png')\n.add('player', '/img/teamfun/player.png');\n\nconst tilemap = {};\nlet player;\nlet playerMoves = {\n    speed: 5,\n    blockLeft: false,\n    blockRight: false,\n    blockBottom: false,\n    blockTop: false,\n    left() {\n        // player.vx = -this.speed;\n        player.movingDirection = 'left';\n    },\n    right() {\n        // player.vx = this.speed;\n        player.movingDirection = 'right';\n    },\n    stop() {\n        // player.vx = 0;\n        player.movingDirection = '';\n    }\n}\nparseTileMap('/img/teamfun/tilemapjsontestcsv.json');\n\n\n \ndocument.body.appendChild(app.view);\n\nfunction setup() {\n    setBackground();\n    tilemap.draw();\n    setPlayer();\n    // create a new Graphics object\n    \n    graphics2.beginFill(0xfff012,1);\n    graphics2.drawPolygon([0,0, 78,0, 78,78, 0,78]);\n    graphics2.endFill();\n    app.stage.addChild(graphics2);\n\n    var graphics = new PIXI.Graphics();\n    // set a fill color and an opacity\n    graphics.beginFill(0xfff012,1);\n    // draw a rectangle using the arguments as:  x, y, radius\n    graphics.drawPolygon([350,700, 500,700, 425,600]);\n    graphics.drawPolygon([0, 0, 128,0, 128, 128, 0, 128]);\n    graphics.endFill();\n    // add it to your scene\n    app.stage.addChild(graphics);\n    app.ticker.add(delta => update(delta));\n}\nconsole.log('height----------',app.renderer.height);\nfunction update(delta) {\n    // Update the collision system\n    player.prevX = player.x;\n    player.prevY = player.y;\n    // jump\n    if (player.jump){\n        player.yMomentum += player.gravity;\n        player.vy = -player.jumpHeight + player.yMomentum;\n    } else {\n        // player.vy = 5;\n    }\n    //move\n    // if (player.movingDirection == 'right'){\n    //     if (yChanged()){\n    //         player.speedPerFrame = player.speedPerFrameInTheAir;\n    //     } else {\n    //         player.speedPerFrame = player.speedPerFrameOnTheGround;\n    //     }\n    //     if (player.vx <= player.maxSpeed)\n    //         player.vx += player.speedPerFrame;\n    // } else if (player.movingDirection == 'left') {\n    //     if (yChanged()){\n    //         player.speedPerFrame = player.speedPerFrameInTheAir;\n    //     } else {\n    //         player.speedPerFrame = player.speedPerFrameOnTheGround;\n    //     }\n    //     if (player.vx >= -player.maxSpeed)\n    //         player.vx -= player.speedPerFrame;\n    // } else {\n    //     if (yChanged()){\n    //         player.speedPerFrame = player.speedPerFrameFalling;\n    //     } else {\n    //         player.speedPerFrame = player.speedPerFrameOnTheGround;\n    //     }\n    //     if (player.vx + player.speedPerFrame < 0){\n    //         player.vx += player.speedPerFrame;\n    //     } else if (player.vx - player.speedPerFrame > 0){\n    //         player.vx -= player.speedPerFrame;\n    //     } else {\n    //         player.vx = 0;\n    //     }\n    // }\n    checkCollision();\n}\n\n\nfunction checkCollision() {\n    // Get any potential collisions (this quickly rules out walls that have no chance of colliding with the collPlayer)\n\n    collPlayer.x = player.x + player.vx;\n    collPlayer.y = player.y + player.vy;\n    graphics2.x = collPlayer.x;\n    graphics2.y = collPlayer.y;\n    \n    collision.update();\n    const collPotentials = collPlayer.potentials();\n    let yCollided = false;\n    let xCollided = false;\n\n    // Loop through the potential wall collisions\n    for(const wall of collPotentials) {\n        // Test if the collPlayer collides with the wall\n        if(collPlayer.collides(wall, collResult)) {\n            // console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!',  collResult, collResult.overlap_x);\n\n            // Push the collPlayer out of the wall\n            console.log('!!!!!!!!!!!!!!overlap',collResult.overlap);\n\n            if (collResult.overlap_x == -1){\n                xCollided = true;\n                // player.x = Math.round(player.x + collResult.overlap - 1);\n                player.vx = 0;\n                return 'left';\n            }\n            if (collResult.overlap_x == 1){\n                xCollided = true;\n                player.vx = 0;\n                // player.x = Math.round(player.x - collResult.overlap + 1);\n                return 'right';\n            }\n            if (collResult.overlap_y == 1){\n                yCollided = true;\n                console.log('y 1');\n                player.yMomentum = 0;\n                player.vy = 0;\n                player.jump = false;\n            }\n            if (collResult.overlap_y == -1){\n                yCollided = true;\n                console.log('y -1');\n                \n                // player.yMomentum\n            }\n        }\n    }\n    console.log(collResult.overlap_x, collResult.overlap_y);\n    \n    if (!xCollided){\n        console.log('movingX');\n        player.x += player.vx;\n    }\n    if (!yCollided){\n        console.log('movingY');\n        player.y += player.vy;\n    }\n    \n    \n}\n\nfunction xChanged() {\n    if (player.x !== player.prevX){\n        return false;\n    } else {\n        return true\n    }\n}\nfunction yChanged() {\n    if (player.y !== player.prevY){\n        return false;\n    } else {\n        return true\n    }\n}\n\nfunction setPlayer() {\n    player = new PIXI.Sprite(\n        PIXI.loader.resources['player'].texture\n    );\n    player.position.set(350,500);\n    player.maxSpeed = 10;\n    player.vx = 0;\n    player.vy = 0;\n    // player.vy = 5;\n    player.gravity = 0.5;\n    player.yMomentum = 0;\n    player.jumpHeight = 15;\n    player.speedPerFrameOnTheGround = player.maxSpeed/7;\n    player.speedPerFrameInTheAir = player.maxSpeed/15;\n    player.speedPerFrameFalling = player.maxSpeed/35;\n    player.speedPerFrame = player.speedPerFrameOnTheGround;\n\n    app.stage.addChild(player);\n    playerMoveInit();\n}\n\nfunction playerMoveInit(){\n    let left = keyboard('ArrowLeft'),\n        right = keyboard('ArrowRight'),\n        up = keyboard('ArrowUp'),\n        down = keyboard('ArrowDown');\n\n    // left.press = () => {\n    //     playerMoves.left();\n    // };\n    // left.release = () => {\n    //     if (!right.isDown) {\n    //         playerMoves.stop();\n    //     } else {\n    //         playerMoves.right();\n    //     }\n    // };\n    // up.press = () => {\n    //     if (!player.jump){\n    //         player.jump = true;\n    //     }\n    // };\n    // right.press = () => {\n    //     playerMoves.right();\n    // };\n    // right.release = () => {\n    //     if (!left.isDown) {\n    //         playerMoves.stop();\n    //     } else {\n    //         playerMoves.left();\n    //     }\n    // };\n    left.press = () => {\n        player.vx = -5;\n        player.vy = 0;\n    };\n    left.release = () => {\n        if (!right.isDown && player.vy === 0) {\n            player.vx = 0;\n        }\n    };\n    up.press = () => {\n        player.vy = -5;\n        player.vx = 0;\n    };\n    up.release = () => {\n        if (!down.isDown && player.vx === 0) {\n            player.vy = 0;\n        }\n    };\n    right.press = () => {\n        player.vx = 5;\n        player.vy = 0;\n    };\n    right.release = () => {\n        if (!left.isDown && player.vy === 0) {\n            player.vx = 0;\n        }\n    };\n    down.press = () => {\n        player.vy = 5;\n        player.vx = 0;\n    };\n    down.release = () => {\n        if (!up.isDown && player.vx === 0) {\n            player.vy = 0;\n        }\n    };\n}\n\nfunction changeVelocity(intensity, changeTo, velocityVector = 'vx'){\n    if (player[velocityVector] < changeTo){\n        player[velocityVector] += intensity;\n    } else {\n        player[velocityVector] -= intensity;\n    }\n}\n\nfunction setBackground() {\n    let bg = new PIXI.Sprite(\n        PIXI.loader.resources['background'].texture\n    );\n    app.stage.addChild(bg);\n}\n\nfunction parseTileMap(tilemapSource){\n    fetch(tilemapSource)\n    .then(res => res.json())\n    .then(data => {\n        console.log('all json data',data);\n        console.log('------------------------------------');\n        \n        tilemap.rows = data.height;\n        tilemap.cols = data.width;\n        tilemap.tileWidth = data.tilewidth;\n        tilemap.tileHeight = data.tileheight;\n        tilemap.tilemapPrefix = 'tileimg';\n        tilemap.layers = data.layers.map((layer) => {\n            return {\n                data: layer.data\n            }\n        });\n        tilemap.tilesets = data.tilesets.map((tileset) => {\n            return {\n                firstgid: tileset.firstgid,\n                tiles: tileset.tiles\n            }\n        });\n        console.log('Tilemap',tilemap);\n        console.log('------------------------------------');\n        tilemap.loadTiles();\n    });\n    tilemap.loadTiles = function() {\n        let tileImagesArr = [];\n        let tilemapPrefix = tilemap.tilemapPrefix;\n        const pathToImages = '/img/teamfun/';\n        this.tilesets.map((tileset) => {\n            let tileStartId = tileset.firstgid;\n            tileImagesArr = [...tileImagesArr, ...tileset.tiles.map((tile) => {\n                return {\n                    'alias': tilemapPrefix + (tile.id + tileStartId),\n                    'src': tile.image\n                }\n            })]\n        });\n        // load images to pixi\n        tileImagesArr.map((img) => loader.add(img.alias, pathToImages + img.src));\n        loader.load(setup);\n    }\n    tilemap.draw = function() {\n        let tileWidth = tilemap.tileWidth;\n        let tileHeight = tilemap.tileHeight;\n        let cols = tilemap.cols;\n        tilemap.layers.map((layer) => {\n            let rowNumber = 1;\n            layer.data.map((tile, index) => {\n                if (tile != 0) {\n                    let tileX = (index - cols*(rowNumber-1)) * tileWidth;\n                    let tileY = rowNumber * tileHeight;\n                    \n                    tilemap.setTileOnMap(tileX,tileY,`${tilemap.tilemapPrefix}${tile}`);\n                }\n                if ((index + 1)%cols == 0)\n                    rowNumber += 1;\n            });\n        });\n    }\n    tilemap.setTileOnMap = function(x,y,alias) {\n        let tile = new PIXI.Sprite(\n            PIXI.loader.resources[alias].texture\n        );\n        tile.position.set(x,y-tile.height);\n        app.stage.addChild(tile);\n    }\n}\n\nfunction Player(x, y) {\n    this.x = x;\n}\n\n// Keyboard -------------------------------------------------\n\nfunction keyboard(value) {\n    let key = {};\n    key.value = value;\n    key.isDown = false;\n    key.isUp = true;\n    key.press = undefined;\n    key.release = undefined;\n    //The `downHandler`\n    key.downHandler = event => {\n      if (event.key === key.value) {\n        if (key.isUp && key.press) key.press();\n        key.isDown = true;\n        key.isUp = false;\n        event.preventDefault();\n      }\n    };\n  \n    //The `upHandler`\n    key.upHandler = event => {\n      if (event.key === key.value) {\n        if (key.isDown && key.release) key.release();\n        key.isDown = false;\n        key.isUp = true;\n        event.preventDefault();\n      }\n    };\n  \n    //Attach event listeners\n    const downListener = key.downHandler.bind(key);\n    const upListener = key.upHandler.bind(key);\n    \n    window.addEventListener(\n      \"keydown\", downListener, false\n    );\n    window.addEventListener(\n      \"keyup\", upListener, false\n    );\n    \n    // Detach event listeners\n    key.unsubscribe = () => {\n      window.removeEventListener(\"keydown\", downListener);\n      window.removeEventListener(\"keyup\", upListener);\n    };\n    \n    return key;\n}\n\n// Keyboard END -------------------------------------------------"],"sourceRoot":""}